<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 2 Makefile | A Minimal Book Example</title>
  <meta name="description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 2 Makefile | A Minimal Book Example" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 2 Makefile | A Minimal Book Example" />
  
  <meta name="twitter:description" content="This is a minimal example of using the bookdown package to write a book. The output format for this example is bookdown::gitbook." />
  

<meta name="author" content="Yihui Xie" />


<meta name="date" content="2020-04-08" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="linux-sh-.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />












<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">A Minimal Book Example</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> 引入</a></li>
<li class="chapter" data-level="2" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>2</b> Makefile</a><ul>
<li class="chapter" data-level="2.1" data-path="intro.html"><a href="intro.html#一个示例"><i class="fa fa-check"></i><b>2.1</b> 一个示例</a></li>
<li class="chapter" data-level="2.2" data-path="intro.html"><a href="intro.html#make是如何工作的"><i class="fa fa-check"></i><b>2.2</b> make是如何工作的</a></li>
<li class="chapter" data-level="2.3" data-path="intro.html"><a href="intro.html#makefile中使用变量"><i class="fa fa-check"></i><b>2.3</b> makefile中使用变量</a></li>
<li class="chapter" data-level="2.4" data-path="intro.html"><a href="intro.html#让make自动推导"><i class="fa fa-check"></i><b>2.4</b> 让make自动推导</a></li>
<li class="chapter" data-level="2.5" data-path="intro.html"><a href="intro.html#清空目标文件的规则"><i class="fa fa-check"></i><b>2.5</b> 清空目标文件的规则</a></li>
<li class="chapter" data-level="2.6" data-path="intro.html"><a href="intro.html#makefile的文件名"><i class="fa fa-check"></i><b>2.6</b> Makefile的文件名</a></li>
<li class="chapter" data-level="2.7" data-path="intro.html"><a href="intro.html#使用变量"><i class="fa fa-check"></i><b>2.7</b> 使用变量</a><ul>
<li class="chapter" data-level="2.7.1" data-path="intro.html"><a href="intro.html#一变量的基础"><i class="fa fa-check"></i><b>2.7.1</b> 一、变量的基础</a></li>
<li class="chapter" data-level="2.7.2" data-path="intro.html"><a href="intro.html#变量赋值"><i class="fa fa-check"></i><b>2.7.2</b> 变量赋值</a></li>
<li class="chapter" data-level="2.7.3" data-path="intro.html"><a href="intro.html#自动化变量"><i class="fa fa-check"></i><b>2.7.3</b> 自动化变量</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="linux-sh-.html"><a href="linux-sh-.html"><i class="fa fa-check"></i><b>3</b> linux.sh语法</a><ul>
<li class="chapter" data-level="3.1" data-path="linux-sh-.html"><a href="linux-sh-.html#开头"><i class="fa fa-check"></i><b>3.1</b> 开头</a></li>
<li class="chapter" data-level="3.2" data-path="linux-sh-.html"><a href="linux-sh-.html#注释"><i class="fa fa-check"></i><b>3.2</b> 注释</a></li>
<li class="chapter" data-level="3.3" data-path="linux-sh-.html"><a href="linux-sh-.html#变量"><i class="fa fa-check"></i><b>3.3</b> 变量</a></li>
<li class="chapter" data-level="3.4" data-path="linux-sh-.html"><a href="linux-sh-.html#环境变量"><i class="fa fa-check"></i><b>3.4</b> 环境变量</a></li>
<li class="chapter" data-level="3.5" data-path="linux-sh-.html"><a href="linux-sh-.html#shell命令和流程控制"><i class="fa fa-check"></i><b>3.5</b> Shell命令和流程控制</a><ul>
<li class="chapter" data-level="3.5.1" data-path="linux-sh-.html"><a href="linux-sh-.html#unix-命令"><i class="fa fa-check"></i><b>3.5.1</b> 1. Unix 命令:</a></li>
<li class="chapter" data-level="3.5.2" data-path="linux-sh-.html"><a href="linux-sh-.html#概念-管道-重定向和-backtick"><i class="fa fa-check"></i><b>3.5.2</b> 2. 概念: 管道, 重定向和 backtick</a></li>
<li class="chapter" data-level="3.5.3" data-path="linux-sh-.html"><a href="linux-sh-.html#流程控制"><i class="fa fa-check"></i><b>3.5.3</b> 3. 流程控制</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="methods.html"><a href="methods.html"><i class="fa fa-check"></i><b>4</b> Methods</a></li>
<li class="chapter" data-level="5" data-path="applications.html"><a href="applications.html"><i class="fa fa-check"></i><b>5</b> Applications</a><ul>
<li class="chapter" data-level="5.1" data-path="applications.html"><a href="applications.html#example-one"><i class="fa fa-check"></i><b>5.1</b> Example one</a></li>
<li class="chapter" data-level="5.2" data-path="applications.html"><a href="applications.html#example-two"><i class="fa fa-check"></i><b>5.2</b> Example two</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="final-words.html"><a href="final-words.html"><i class="fa fa-check"></i><b>6</b> Final Words</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">A Minimal Book Example</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="intro" class="section level1">
<h1><span class="header-section-number">Chapter 2</span> Makefile</h1>
<p>基本转载教程<a href="https://blog.csdn.net/ruglcc/article/details/7814546">Makefile CSDN</a>
## Makefile的规则
在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p>
<pre><code>     target... : prerequisites ...

          command</code></pre>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。prerequisites就是，要生成那个target所需要的文件或是目标。command也就是make需要执行的命令。（任意的Shell命令）这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<div id="一个示例" class="section level2">
<h2><span class="header-section-number">2.1</span> 一个示例</h2>
<p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p>
<pre><code>   edit : main.o kbd.o command.o display.o \

          insert.o search.o files.o utils.o

           cc -o edit main.o kbd.o command.o display.o \

                      insert.o search.o files.o utils.o

 

   main.o : main.c defs.h

           cc -c main.c

   kbd.o : kbd.c defs.h command.h

           cc -c kbd.c

   command.o : command.c defs.h command.h

           cc -c command.c

   display.o : display.c defs.h buffer.h

           cc -c display.c

   insert.o : insert.c defs.h buffer.h

           cc -c insert.c

   search.o : search.c defs.h buffer.h

           cc -c search.c

   files.o : files.c defs.h buffer.h command.h

           cc -c files.c

   utils.o : utils.c defs.h

           cc -c utils.c

   clean :

           rm edit main.o kbd.o command.o display.o \

              insert.o search.o files.o utils.o</code></pre>
<p>我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，<strong>其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。</strong>这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
</div>
<div id="make是如何工作的" class="section level2">
<h2><span class="header-section-number">2.2</span> make是如何工作的</h2>
<p>在默认的方式下，也就是我们只输入make命令。那么，make会在当前目录下找名字叫“Makefile”或“makefile”的文件。如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。
如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。
如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）
当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。
这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。
通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。</p>
<p>而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
</div>
<div id="makefile中使用变量" class="section level2">
<h2><span class="header-section-number">2.3</span> makefile中使用变量</h2>
<p>在上面的例子中，先让我们看看edit的规则：</p>
<pre><code>     edit : main.o kbd.o command.o display.o \

                 insert.o search.o files.o utils.o

           cc -o edit main.o kbd.o command.o display.o \

                      insert.o search.o files.o utils.o</code></pre>
<pre><code>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</code></pre>
<p>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p>
<pre><code>    objects = main.o kbd.o command.o display.o \

             insert.o search.o files.o utils.o</code></pre>
<p>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p>
<pre><code>   objects = main.o kbd.o command.o display.o \
             insert.osearch.o files.o utils.o 
   edit : $(objects)
           cc -o edit $(objects)
   main.o : main.c defs.h
           cc -c main.c
   kbd.o : kbd.c defs.h command.h
           cc -c kbd.c
   command.o : command.c defs.h command.h
           cc -c command.c
   display.o : display.c defs.h buffer.h
           cc -c display.c
   insert.o : insert.c defs.h buffer.h
           cc -c insert.c
   search.o : search.c defs.h buffer.h
           cc -c search.c
   files.o : files.c defs.h buffer.h command.h
           cc -c files.c
   utils.o : utils.c defs.h
           cc -c utils.c
   clean :
           rm edit $(objects)</code></pre>
<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。</p>
<p>关于变量更多的话题，我会在后续给你一一道来。</p>
</div>
<div id="让make自动推导" class="section level2">
<h2><span class="header-section-number">2.4</span> 让make自动推导</h2>
<p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p>
<pre><code>   objects = main.o kbd.o command.o display.o \
             insert.o search.o files.o utils.o
 
   edit : $(objects)
           cc -o edit $(objects)
 
   main.o : defs.h
   kbd.o : defs.h command.h
   command.o : defs.h command.h
   display.o : defs.h buffer.h
   insert.o : defs.h buffer.h
   search.o : defs.h buffer.h
   files.o : defs.h buffer.h command.h
   utils.o : defs.h
 
   .PHONY : clean
   clean :
           rm edit $(objects)</code></pre>
<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。</p>
</div>
<div id="清空目标文件的规则" class="section level2">
<h2><span class="header-section-number">2.5</span> 清空目标文件的规则</h2>
<pre><code>  每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</code></pre>
<pre><code>       clean:

           rm edit $(objects)</code></pre>
<p>更为稳健的做法是：</p>
<pre><code>       .PHONY : clean

       clean :

               -rm edit $(objects)</code></pre>
<p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。</p>
<p>上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节。</p>
</div>
<div id="makefile的文件名" class="section level2">
<h2><span class="header-section-number">2.6</span> Makefile的文件名</h2>
<p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如：make -f Make.Linux或make –file Make.AIX。</p>
</div>
<div id="使用变量" class="section level2">
<h2><span class="header-section-number">2.7</span> 使用变量</h2>
<p>在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“<span class="math inline">\(&lt;”、“\)</span>@”等，这些是自动化变量，我会在后面介绍。</p>
<div id="一变量的基础" class="section level3">
<h3><span class="header-section-number">2.7.1</span> 一、变量的基础</h3>
<p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号,但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。</p>
<p>先看一个例子：</p>
<pre><code>objects = program.o foo.o utils.o
program : $(objects)
cc -o program $(objects)

$(objects) : defs.h</code></pre>
<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p>
<pre><code>foo = c
prog.o : prog.$(foo)
$(foo)$(foo) -$(foo) prog.$(foo)</code></pre>
<p>展开后得到：</p>
<pre><code>prog.o : prog.c
cc -c prog.c</code></pre>
</div>
<div id="变量赋值" class="section level3">
<h3><span class="header-section-number">2.7.2</span> 变量赋值</h3>
<p>这种方法使用的是“:=”操作符，如：</p>
<pre><code>x := foo
y := $(x) bar
x := later</code></pre>
<p>其等价于：</p>
<pre><code>y := foo bar
x := later</code></pre>
<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>
<pre><code>y := $(x) bar
x := foo</code></pre>
<p>那么，y的值是“bar”，而不是“foo bar”。</p>
</div>
<div id="自动化变量" class="section level3">
<h3><span class="header-section-number">2.7.3</span> 自动化变量</h3>
<p>关于自动化变量可以理解为由 Makefile 自动产生的变量。在模式规则中，规则的目标和依赖的文件名代表了一类的文件。规则的命令是对所有这一类文件的描述。我们在 Makefile 中描述规则时，依赖文件和目标文件是变动的，显然在命令中不能出现具体的文件名称，否则模式规则将失去意义。那么模式规则命令中该如何表示文件呢？就需要使用“自动化变量”，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标文件和依赖文件。下面是对所有的自动化变量进行的说明：</p>
<ul>
<li>$@ 表示规则的目标文件名。如果目标是一个文档文件（Linux 中，一般成 .a 文件为文档文件，也成为静态的库文件），
那么它代表这个文档的文件名。在多目标模式规则中，它代表的是触发规则被执行的文件名。</li>
<li>$% 当目标文件是一个静态库文件时，代表静态库的一个成员名。</li>
<li>$&lt; 规则的第一个依赖的文件名。如果是一个目标文件使用隐含的规则来重建，则它代表由隐含规则加入的第一个依赖文件。</li>
<li>$? 所有比目标文件更新的依赖文件列表，空格分隔。如果目标文件时静态库文件，代表的是库文件（.o 文件）。</li>
<li>$^ 代表的是所有依赖文件列表，使用空格分隔。如果目标是静态库文件，它所代表的只能是所有的库成员（.o 文件）名。
一个文件可重复的出现在目标的依赖中，变量“$<sup>”只记录它的第一次引用的情况。就是说变量“$</sup>”会去掉重复的依赖文件。</li>
<li>$+ 类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。
$*| 在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时，
“茎”也包含目录部分）。
下面我们就自动化变量的使用举几个例子。</li>
</ul>
<p>实例1：</p>
<pre><code>test:test.o test1.o test2.o
         gcc -o $@ $^
test.o:test.c test.h
         gcc -o $@ $&lt;
test1.o:test1.c test1.h
         gcc -o $@ $&lt;
test2.o:test2.c test2.h
         gcc -o $@ $&lt;</code></pre>
<p>这个规则模式中用到了 “$@” 、“$&lt;” 和 “$^” 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现 “$@” 代表的是目标文件test，“$^”代表的是依赖的文件，“$&lt;”代表的是依赖文件中的第一个。我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。</p>
<p>实例2：</p>
<pre><code>lib:test.o test1.o test2.o
    ar r $?</code></pre>
<p>假如我们要做一个库文件，库文件的制作依赖于这三个文件。当修改了其中的某个依赖文件，在命令行执行 make 命令，库文件 “lib” 就会自动更新。“$?” 表示修改的文件。</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="linux-sh-.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/01-intro.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["bookdown-demo.pdf", "bookdown-demo.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
